## 电话本项目

从文件读取数据到链表时，先用`fgets()`把文件中的数据一行一行的存在字符数组中；

再用`sscanf()`把字符数中的数据存到链表中

`sscanf` 和 `fscanf` 都是用于从字符串或文件中读取数据的函数，它们各自有其适用的场景和优势。

**sscanf**：

- 优势：
  - `sscanf` 适用于从字符串中解析数据。如果你已经有一个字符串，想要从中提取数据并进行处理，那么 `sscanf` 是一个很方便的选择。
  - `sscanf` 可以直接处理内存中的字符串，不需要考虑文件 I/O，因此更加灵活。
- 不足：
  - `sscanf` 需要将整个字符串读入内存中，如果字符串较大或者需要频繁处理大量数据，可能会导致内存消耗增加。
  - 对于大规模数据的处理，可能效率不如直接从文件中读取。

**fscanf**：

- 优势：
  - `fscanf` 适用于从文件中读取数据。如果你需要处理大量数据存储在文件中，那么 `fscanf` 是一个更合适的选择。
  - `fscanf` 可以直接从文件流中读取数据，避免了将整个文件读入内存的开销。
- 不足：
  - `fscanf` 需要处理文件 I/O，相比于 `sscanf` 在处理字符串时可能稍显麻烦。
  - 对于需要频繁处理大量字符串数据的情况，可能效率不如 `sscanf`。

综上所述，选择使用 `sscanf` 还是 `fscanf` 取决于你的具体需求。如果你需要从字符串中解析数据或者数据规模较小，可以考虑使用 `sscanf`。如果你需要处理大量存储在文件中的数据，可以选择使用 `fscanf`。

`sscanf(line, "%d,%49[^,],%19[^,],%99[^\n]", &newnode->id, newnode->name, newnode->phonenum, newnode->note);` 这一行代码是从字符串 `line` 中按照指定的格式读取数据，并将这些数据存储到 `newnode` 结构体的成员中。以下是具体的解释：

### 格式字符串详解

- `"%d,%49[^,],%19[^,],%99[^\n]"` 是格式字符串，它定义了如何从 `line` 中解析数据：
  - `%d`：读取一个整数，并存储到 `newnode->id` 中。
  - `,%49[^,]`：读取一个以逗号分隔的字符串，最多读取 49 个字符，直到遇到逗号为止。读取的字符串存储到 `newnode->name` 中。`[^,]` 表示匹配所有非逗号的字符。
  - `,%19[^,]`：读取另一个以逗号分隔的字符串，最多读取 19 个字符，直到遇到逗号为止。读取的字符串存储到 `newnode->phonenum` 中。
  - `,%99[^\n]`：读取最后一个以逗号分隔的字符串，最多读取 99 个字符，直到遇到换行符为止。读取的字符串存储到 `newnode->note` 中。

### 具体解析步骤

假设 `line` 的内容是 `"1,John Doe,123-456-7890,Friend from work"`，那么 `sscanf` 将按照如下方式解析：

1. `"%d"`：从 `line` 的开头读取一个整数 `1`，并将其存储到 `newnode->id` 中。
2. `",%49[^,]"`：跳过一个逗号 `,`，然后读取最多 49 个非逗号字符 `"John Doe"`，并将其存储到 `newnode->name` 中。
3. `",%19[^,]"`：跳过一个逗号 `,`，然后读取最多 19 个非逗号字符 `"123-456-7890"`，并将其存储到 `newnode->phonenum` 中。
4. `",%99[^\n]"`：跳过一个逗号 `,`，然后读取最多 99 个非换行符字符 `"Friend from work"`，并将其存储到 `newnode->note` 中。

### 参数解释

- `line`：包含要解析的字符串。
- `"%d,%49[^,],%19[^,],%99[^\n]"`：格式字符串，指定了如何解析 `line` 中的数据。
- `&newnode->id`：指向 `newnode` 结构体中 `id` 成员的指针，用于存储解析出的整数。
- `newnode->name`：指向 `newnode` 结构体中 `name` 成员的指针，用于存储解析出的名字字符串。
- `newnode->phonenum`：指向 `newnode` 结构体中 `phonenum` 成员的指针，用于存储解析出的电话号码字符串。
- `newnode->note`：指向 `newnode` 结构体中 `note` 成员的指针，用于存储解析出的备注字符串。

### 总结

`sscanf` 函数通过格式字符串 `%d,%49[^,],%19[^,],%99[^\n]` 从 `line` 中解析出一个整数和三个字符串，并将它们分别存储到 `newnode` 结构体的 `id`、`name`、`phonenum` 和 `note` 成员中。这种方法适用于从已知格式的字符串中提取结构化数据。

#### 读取文件

```c
newnode->next=NULL;
        if(!head){
            head=newnode;
        }
        else{
            PHONE *cur=head;
            while(cur->next){
                cur=cur->next;
            }
            cur->next=newnode;
        }
```

下面是这个代码段的图示解释，这段代码的作用是将一个新节点 `newnode` 添加到链表的末尾。我们用图示来说明这个过程。

### 初始状态

假设当前链表是空的，或者已经有一些节点。我们将展示两种情况：

#### 情况 1：链表为空

- 初始状态：
  ```
  head -> NULL
  ```

#### 情况 2：链表已有一些节点

- 初始状态：
  ```
  head -> [Node1] -> [Node2] -> NULL
  ```

### 1. 初始化新节点的 `next` 指针

不论链表是否为空，我们首先初始化新节点的 `next` 指针：

```c
newnode->next = NULL;
```

此时新节点 `newnode` 的状态为：
```
newnode -> [NewNode] -> NULL
```

### 2. 检查链表是否为空

#### 情况 1：链表为空

```c
if (!head) {
    head = newnode;
}
```

- 检查 `head` 是否为 `NULL`。如果是，表示链表为空。
- 将 `head` 指向 `newnode`，使 `newnode` 成为链表的第一个节点。

图示：

```
head -> [NewNode] -> NULL
```

#### 情况 2：链表已有一些节点

```c
else {
    PHONE *cur = head;
    while (cur->next) {
        cur = cur->next;
    }
    cur->next = newnode;
}
```

- 声明一个指针 `cur` 并将其初始化为 `head`。
- 使用 `while (cur->next)` 循环遍历链表，直到找到最后一个节点。
- 将最后一个节点的 `next` 指针指向 `newnode`。

### 图示过程

#### 初始链表
```
head -> [Node1] -> [Node2] -> NULL
```

#### 第一步：声明 `cur` 并初始化为 `head`
```
cur
 |
 v
head -> [Node1] -> [Node2] -> NULL
```

#### 第二步：遍历链表，找到最后一个节点

- `cur = cur->next` 执行一次
```
        cur
         |
         v
head -> [Node1] -> [Node2] -> NULL
```

- `cur = cur->next` 执行第二次
```
                cur
                 |
                 v
head -> [Node1] -> [Node2] -> NULL
```

#### 第三步：将最后一个节点的 `next` 指针指向 `newnode`
```
cur->next = newnode;
```

图示结果：

```
head -> [Node1] -> [Node2] -> [NewNode] -> NULL
```

### 完整过程总结

无论链表最初是空的还是已有一些节点，代码都会将 `newnode` 正确地添加到链表的末尾。通过初始化新节点的 `next` 指针为 `NULL`，然后检查链表是否为空，来决定是将新节点作为第一个节点，还是将其链接到已有链表的末尾。这个过程有效地管理了链表结构，确保新节点总是添加到链表的末尾。

### 删除

```c
PHONE *cur=head;
    PHONE *pre=NULL;
    while(cur&&cur->id!=id){
        pre=cur;
        cur=cur->next;
    }
    if(!cur){
        printf("未找到联系人\n");
    }
    if(!pre){
        pre->next=cur->next;
    }
    free(cur);
    count--;
    cur=head;
    int index=1;
    while(cur){
        cur->id=index++;
        cur=cur->next;
    }
```

这段代码是用来删除链表中指定ID的节点的。下面逐步解释其删除过程：

1. **初始化指针：**
   - `cur` 和 `pre` 分别指向链表的头部和 `NULL`。`cur` 用于遍历链表，`pre` 则是用来记录 `cur` 的前一个节点。

2. **遍历链表直到找到要删除的节点：**
   - 这个过程通过一个 `while` 循环实现。条件 `cur && cur->id != id` 意味着只要 `cur` 不为空且当前节点的 ID 不等于要删除的 ID，就继续遍历。
   - 在循环内部，`pre` 被设置为 `cur` 的前一个节点，`cur` 移动到下一个节点。

3. **检查是否找到要删除的节点：**
   - 如果 `cur` 为空，说明遍历完整个链表都没有找到要删除的节点，那么打印未找到联系人的消息。
   
4. **删除节点：**
   - 如果 `pre` 为空（即头节点就是要删除的节点），则直接将头指针 `head` 指向当前节点的下一个节点 `cur->next`，从而跳过当前节点。然后释放当前节点 `cur` 占用的内存。
   - 如果 `pre` 不为空，则将 `pre->next` 指向 `cur->next`，然后释放当前节点 `cur` 占用的内存。

5. **更新计数和节点ID：**
   - 减少节点计数 `count`。
   - 重新遍历链表，并为每个节点重新分配ID，从而保持节点ID的顺序性。

综上所述，这段代码删除节点的过程包括查找要删除的节点、调整指针、释放内存以及更新链表中的节点ID。